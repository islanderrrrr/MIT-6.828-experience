# 物理内存页管理
操作系统必须跟踪物理 RAM 的哪些部分是空闲的，哪些部分目前正在使用。JOS 使用页面粒度管理 PC 的物理内存，以便使用 MMU 映射和保护分配的每个内存块。

现在，你将编写物理页面分配器。它通过一个 PageInfo 结构体对象的链表来跟踪哪些页面是空闲的(与 xv6 不同的是，这些对象并没有嵌入到空闲页面本身中)，每个结构体对应一个物理页面。在编写虚拟内存实现的其余部分之前，你需要编写物理页分配器，因为页表管理代码将需要分配用于存储页表的物理内存。

**练习 1：在文件 kern/mmap.c 中，实现以下函数的代码(可能按照给定的顺序)。**
```
boot_alloc()
mem_init() (only up to the call to check_page_free_list(1))
page_init()
page_alloc()
page_free()
```

在实现代码之前，需要理解几个关键概念：

1. 页（Page）：物理内存以 4096 字节（4KB）为单位管理
2. PageInfo 结构体：跟踪每个物理页的状态
3. 页表（Page Table）：用于虚拟地址到物理地址的映射

# boot_alloc()
这是一个临时的物理内存分配器，只在 JOS 设置虚拟内存系统之前使用。

**功能：**

- 分配 n 字节的物理内存
- 返回内核虚拟地址
- 如果 n == 0，返回下一个空闲页的地址但不分配

**完善：**
```
static void *
boot_alloc(uint32_t n)
{
	static char *nextfree;	// virtual address of next byte of free memory
	char *result;

	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
	}

	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
	
	// 保存当前的 nextfree 作为返回值
	result = nextfree;
	
	// 如果 n > 0，分配内存并更新 nextfree
	// 确保 nextfree 始终对齐到 PGSIZE
	if (n > 0) {
		nextfree = ROUNDUP(nextfree + n, PGSIZE);
		// 确保分配的内存是页对齐的，这对后续的页表管理很重要

		// 检查是否超出物理内存范围
		// npages 是系统中物理页的总数
		// KERNBASE 是内核在虚拟地址空间中的起始地址
		if ((uint32_t)nextfree - KERNBASE > npages * PGSIZE) {
			panic("boot_alloc: out of memory\n");
		}
	}
	
	return result;
}
```

**代码详解:**
1. static char *nextfree: 这是一个静态变量，记录下一个空闲字节的虚拟地址

2. 初始化部分（已有）:
- 第一次调用时，将 nextfree 初始化为 end 符号之后的第一个页边界
- end 是链接器生成的符号，指向内核 BSS 段的末尾
- ROUNDUP() 将地址向上对齐到页边界（4096 字节）
3. 你需要添加的部分:
- 保存当前地址: result = nextfree - 这是要返回的地址
- 更新 nextfree: 如果 n > 0，将 nextfree 向前移动 n 字节，并对齐到页边界
- 边界检查: 确保没有超出物理内存范围

**关键宏和变量:**
- PGSIZE: 页大小，通常是 4096 字节
- ROUNDUP(a, n): 将 a 向上取整到 n 的倍数
- KERNBASE: 内核虚拟地址的起始位置（通常是 0xF0000000）
- npages: 系统中物理页的总数
- PADDR(kva): 将内核虚拟地址转换为物理地址

# mem_init(): 
这个函数负责设置内存管理系统。在 Part 1 中，我们只需要完成到 page_init() 调用之前的部分。

1. 删除 panic 语句
```
// panic("mem_init: This function is not finished\n");  // 注释掉这一行
```
这行代码会导致内核立即停止。当你准备测试时，必须删除或注释掉它。

2. 创建初始页目录（已提供）
```
kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
memset(kern_pgdir, 0, PGSIZE);
```
- 分配一页内存（4096 字节）作为页目录
- 用 0 初始化整个页目录
3. 递归插入页目录（已提供）
```
kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
```
这是一个很巧妙的技巧，将页目录映射到自己，创建一个虚拟页表。暂时不需要深入理解。

4. 分配 PageInfo 数组（你需要添加的部分）
```
pages = (struct PageInfo *) boot_alloc(npages * sizeof(struct PageInfo));
memset(pages, 0, npages * sizeof(struct PageInfo));
```
- pages 是一个全局数组，用于跟踪所有物理页的状态
- npages 是系统中物理页的总数（由 i386_detect_memory() 设置）
- 每个物理页对应一个 struct PageInfo 结构体
- memset() 将所有字段初始化为 0（pp_ref = 0, pp_link = NULL）

**PageInfo 结构体**
```
struct PageInfo {
	// 指向下一个空闲页的指针（链表）
	// 如果页面已分配，则为 NULL
	struct PageInfo *pp_link;
	
	// 引用计数：有多少个指针指向这个页面
	// 当 pp_ref == 0 时，页面是空闲的
	uint16_t pp_ref;
};
```

```
物理内存:
┌─────────────────┐ 0x00000000
│     Page 0      │ ← 被 BIOS/real mode 使用
├─────────────────┤ 0x00001000
│   Pages 1-159   │ ← 基础内存（空闲）
├─────────────────┤ 0x000A0000 (IOPHYSMEM)
│    IO Hole      │ ← VGA, BIOS ROM 等
├─────────────────┤ 0x00100000 (EXTPHYSMEM)
│  Kernel Code    │
│  Kernel Data    │
│  kern_pgdir     │ ← 页目录（1 页）
│  pages[] 数组   │ ← PageInfo 数组
├─────────────────┤ ← nextfree (boot_alloc 的下一个空闲位置)
│   Free Memory   │
│       ...       │
└─────────────────┘
```

# page_init()
内存布局分析

```
物理内存布局:
┌──────────────────┐ 0x00000000
│  Page 0 (4KB)    │ ← 情况 1: BIOS/IDT，标记为已使用
├──────────────────┤ 0x00001000 (PGSIZE)
│  Pages 1-159     │ ← 情况 2: 基础内存，空闲
│  (约 640KB)      │    加入 page_free_list
├──────────────────┤ 0x000A0000 (IOPHYSMEM = 640KB)
│  IO Hole         │ ← 情况 3: VGA、BIOS ROM
│  (384KB)         │    标记为已使用，永不分配
├──────────────────┤ 0x00100000 (EXTPHYSMEM = 1MB)
│  Kernel Code     │
│  Kernel Data     │ ← 情况 4a: 内核占用的部分
│  kern_pgdir      │    标记为已使用
│  pages[] 数组    │
├──────────────────┤ ← first_free_page
│  Free Memory     │ ← 情况 4b: 扩展内存的空闲部分
│      ...         │    加入 page_free_list
└──────────────────┘
```
**关键点**  
1. 物理页 0 (地址 0x0-0xFFF)：

- 保留给 BIOS 和实模式中断描述符表 (IDT)
- pp_ref = 1 标记为已使用
2. 基础内存 [4KB, 640KB)：
  
- 页 1 到 npages_basemem - 1
- 这些页是空闲的，加入 page_free_list
3. IO 空洞 [640KB, 1MB)：
  
- 已占用部分：内核代码、数据、页目录、pages 数组
- 空闲部分：剩余的所有内存
- 使用 boot_alloc(0) 来确定边界
4. 扩展内存 [1MB, ...)：
  
- 已占用部分：内核代码、数据、页目录、pages 数组
- 空闲部分：剩余的所有内存
- 使用 boot_alloc(0) 来确定边界
5. 空闲链表的构建：

- 从后往前构建链表（后加入的在链表头部）
- 这不影响功能，只是链表的顺序

